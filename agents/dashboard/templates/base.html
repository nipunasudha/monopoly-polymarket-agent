<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Monopoly Agents{% endblock %}</title>
    
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- HTMX -->
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    
    <!-- HTMX SSE Extension -->
    <script src="https://unpkg.com/htmx.org@1.9.10/dist/ext/sse.js"></script>
    
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    
    <!-- Alpine.js (load immediately, no defer) -->
    <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.13.5/dist/cdn.min.js"></script>
    
    <style>
        [x-cloak] { display: none !important; }
    </style>
</head>
<body class="bg-gray-50" x-data x-init="$nextTick(() => { if ($store.agent) $store.agent.init(); })">
    <!-- Agent Reactive Store (inline to ensure Alpine is ready) -->
    <script>
        // Wait for Alpine to be ready
        document.addEventListener('alpine:init', () => {
            Alpine.store('agent', {
                // Agent status
                status: {
                    state: 'stopped',
                    running: false,
                    last_run: null,
                    next_run: null,
                    interval_minutes: 60,
                    run_count: 0,
                    error_count: 0,
                    last_error: null,
                    total_forecasts: 0,
                    total_trades: 0
                },

                // Loading states
                loading: {
                    starting: false,
                    stopping: false,
                    running: false,
                },

                // Recent activity
                activities: [],

                // Initialize the store
                init() {
                    this.fetchStatus();
                    this.fetchActivities();
                    this.connectSSE();
                },

                // Fetch current status from API
                async fetchStatus() {
                    try {
                        const response = await fetch('/api/agent/status');
                        const data = await response.json();
                        this.updateStatus(data);
                    } catch (error) {
                        console.error('Failed to fetch status:', error);
                    }
                },

                // Fetch recent activities
                async fetchActivities() {
                    try {
                        const [forecastsRes, tradesRes] = await Promise.all([
                            fetch('/api/forecasts?limit=10'),
                            fetch('/api/trades?limit=10')
                        ]);
                        
                        const forecasts = await forecastsRes.json();
                        const trades = await tradesRes.json();
                        
                        const activities = [
                            ...forecasts.map(f => ({ type: 'forecast', data: f, timestamp: f.created_at })),
                            ...trades.map(t => ({ type: 'trade', data: t, timestamp: t.created_at }))
                        ];
                        
                        activities.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                        this.activities = activities.slice(0, 20);
                    } catch (error) {
                        console.error('Failed to fetch activities:', error);
                    }
                },

                // Connect to SSE stream
                connectSSE() {
                    const eventSource = new EventSource('/api/events/stream');
                    
                    eventSource.addEventListener('agent_status_changed', (e) => {
                        const data = JSON.parse(e.data);
                        this.updateStatus(data);
                    });
                    
                    eventSource.addEventListener('forecast_created', (e) => {
                        const data = JSON.parse(e.data);
                        this.addActivity('forecast', data);
                        this.status.total_forecasts++;
                    });
                    
                    eventSource.addEventListener('trade_executed', (e) => {
                        const data = JSON.parse(e.data);
                        this.addActivity('trade', data);
                        this.status.total_trades++;
                    });
                    
                    eventSource.addEventListener('portfolio_updated', (e) => {
                        const data = JSON.parse(e.data);
                    });

                    eventSource.onerror = () => {
                        console.error('SSE connection error, reconnecting...');
                    };
                },

                // Update status data
                updateStatus(data) {
                    Object.assign(this.status, data);
                },

                // Add activity to feed
                addActivity(type, data) {
                    this.activities.unshift({
                        type,
                        data,
                        timestamp: data.timestamp || new Date().toISOString()
                    });
                    
                    if (this.activities.length > 20) {
                        this.activities = this.activities.slice(0, 20);
                    }
                },

                // Agent control actions (optimistic updates with debouncing)
                async start() {
                    this.loading.starting = true;
                    
                    // Optimistic update - change UI immediately
                    this.status.state = 'running';
                    this.status.running = true;
                    
                    try {
                        const response = await fetch('/api/agent/start', { method: 'POST' });
                        if (!response.ok) throw new Error('Failed to start agent');
                        const data = await response.json();
                        console.log('Agent started:', data);
                        // Don't fetch status immediately - SSE will update it
                        // Wait a bit for SSE event to arrive
                        await new Promise(resolve => setTimeout(resolve, 100));
                    } catch (error) {
                        console.error('Failed to start agent:', error);
                        alert('Failed to start agent: ' + error.message);
                        // Only revert on error
                        this.status.state = 'stopped';
                        this.status.running = false;
                    } finally {
                        this.loading.starting = false;
                    }
                },

                async stop() {
                    this.loading.stopping = true;
                    
                    // Optimistic update
                    this.status.state = 'stopped';
                    this.status.running = false;
                    this.status.next_run = null;
                    
                    try {
                        const response = await fetch('/api/agent/stop', { method: 'POST' });
                        if (!response.ok) throw new Error('Failed to stop agent');
                        const data = await response.json();
                        console.log('Agent stopped:', data);
                        // Don't fetch status immediately - SSE will update it
                        await new Promise(resolve => setTimeout(resolve, 100));
                    } catch (error) {
                        console.error('Failed to stop agent:', error);
                        alert('Failed to stop agent: ' + error.message);
                        // Only revert on error
                        await this.fetchStatus();
                    } finally {
                        this.loading.stopping = false;
                    }
                },

                async pause() {
                    // Optimistic update
                    this.status.state = 'paused';
                    
                    try {
                        const response = await fetch('/api/agent/pause', { method: 'POST' });
                        if (!response.ok) throw new Error('Failed to pause agent');
                        await response.json();
                        // SSE will update status
                    } catch (error) {
                        console.error('Failed to pause agent:', error);
                        alert('Failed to pause agent: ' + error.message);
                        await this.fetchStatus();
                    }
                },

                async resume() {
                    // Optimistic update
                    this.status.state = 'running';
                    this.status.running = true;
                    
                    try {
                        const response = await fetch('/api/agent/resume', { method: 'POST' });
                        if (!response.ok) throw new Error('Failed to resume agent');
                        await response.json();
                        // SSE will update status
                    } catch (error) {
                        console.error('Failed to resume agent:', error);
                        alert('Failed to resume agent: ' + error.message);
                        await this.fetchStatus();
                    }
                },

                async runOnce() {
                    this.loading.running = true;
                    try {
                        const response = await fetch('/api/agent/run-once', { method: 'POST' });
                        const data = await response.json();
                        console.log('Agent run result:', data);
                        await this.fetchActivities();
                    } catch (error) {
                        console.error('Failed to run agent:', error);
                        alert('Failed to run agent: ' + error.message);
                    } finally {
                        this.loading.running = false;
                    }
                },

                async updateInterval(minutes) {
                    try {
                        const response = await fetch('/api/agent/interval', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ interval_minutes: parseInt(minutes) })
                        });
                        const data = await response.json();
                        console.log('Interval updated:', data);
                        this.status.interval_minutes = data.interval_minutes;
                        return data;
                    } catch (error) {
                        console.error('Failed to update interval:', error);
                        throw error;
                    }
                },

                // Computed properties
                get stateColor() {
                    const colors = {
                        running: 'green',
                        stopped: 'gray',
                        paused: 'yellow',
                        error: 'red'
                    };
                    return colors[this.status.state] || 'gray';
                },

                get stateLabel() {
                    const labels = {
                        running: 'Running',
                        stopped: 'Stopped',
                        paused: 'Paused',
                        error: 'Error'
                    };
                    return labels[this.status.state] || 'Unknown';
                },

                get successRate() {
                    if (this.status.run_count === 0) return 0;
                    return ((this.status.run_count - this.status.error_count) / this.status.run_count * 100).toFixed(1);
                },

                get formattedLastRun() {
                    if (!this.status.last_run) return 'Never';
                    return new Date(this.status.last_run).toLocaleString();
                },

                get formattedNextRun() {
                    if (!this.status.next_run) return 'N/A';
                    return new Date(this.status.next_run).toLocaleString();
                }
            });
        });
    </script>
    <!-- Navigation -->
    <nav class="bg-white shadow-sm border-b border-gray-200">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between h-16">
                <div class="flex">
                    <div class="flex-shrink-0 flex items-center">
                        <h1 class="text-xl font-bold text-gray-900">ðŸŽ² Monopoly Agents haha</h1>
                    </div>
                    <div class="hidden sm:ml-6 sm:flex sm:space-x-8">
                        <a href="/" class="{% if request.path == '/' %}border-indigo-500 text-gray-900{% else %}border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700{% endif %} inline-flex items-center px-1 pt-1 border-b-2 text-sm font-medium">
                            Portfolio
                        </a>
                        <a href="/markets" class="{% if request.path == '/markets' %}border-indigo-500 text-gray-900{% else %}border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700{% endif %} inline-flex items-center px-1 pt-1 border-b-2 text-sm font-medium">
                            Markets
                        </a>
                        <a href="/trades" class="{% if request.path == '/trades' %}border-indigo-500 text-gray-900{% else %}border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700{% endif %} inline-flex items-center px-1 pt-1 border-b-2 text-sm font-medium">
                            Trades
                        </a>
                        <a href="/forecasts" class="{% if request.path == '/forecasts' %}border-indigo-500 text-gray-900{% else %}border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700{% endif %} inline-flex items-center px-1 pt-1 border-b-2 text-sm font-medium">
                            Forecasts
                        </a>
                        <a href="/agent" class="{% if request.path == '/agent' %}border-indigo-500 text-gray-900{% else %}border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700{% endif %} inline-flex items-center px-1 pt-1 border-b-2 text-sm font-medium">
                            Agent
                        </a>
                    </div>
                </div>
                <div class="flex items-center">
                    <div class="flex-shrink-0" x-data>
                        <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium"
                              :class="{
                                  'bg-green-100 text-green-800': $store.agent.status.state === 'running',
                                  'bg-gray-100 text-gray-800': $store.agent.status.state === 'stopped',
                                  'bg-yellow-100 text-yellow-800': $store.agent.status.state === 'paused',
                                  'bg-red-100 text-red-800': $store.agent.status.state === 'error'
                              }">
                            <span class="w-2 h-2 mr-2 rounded-full"
                                  :class="{
                                      'bg-green-500': $store.agent.status.state === 'running',
                                      'bg-gray-500': $store.agent.status.state === 'stopped',
                                      'bg-yellow-500': $store.agent.status.state === 'paused',
                                      'bg-red-500': $store.agent.status.state === 'error'
                                  }"></span>
                            <span x-text="$store.agent.stateLabel"></span>
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        {% block content %}{% endblock %}
    </main>

    <!-- Footer -->
    <footer class="bg-white border-t border-gray-200 mt-12">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4">
            <p class="text-center text-sm text-gray-500">
                Monopoly Agents v0.1.0 | Polymarket Prediction Agent System
            </p>
        </div>
    </footer>

    {% block scripts %}{% endblock %}
</body>
</html>
